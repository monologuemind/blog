import{S as A,i as j,s as S,k as g,a as q,e as F,l as _,m as $,h as i,c as E,n as H,b as k,f as m,g as G,t as d,d as J,K as On,q as O,r as R,E as T,G as Rn,u as An,D as jn,H as Hn,I as xn,J as Cn,A as w,v as b,w as h,x as P,y as v}from"../../../../chunks/index-db185f5b.js";import{H as Nn,a as kn}from"../../../../chunks/v4-7b84e476.js";import{C as un}from"../../../../chunks/Collapse-b4b1b797.js";const Dn=c=>({active_tab:c&2}),wn=c=>({active_tab:c[1]});function bn(c,n,a){const s=c.slice();return s[6]=n[a],s}function hn(c){let n,a=c[6].name+"",s,t,p,l;function o(){return c[5](c[6])}return{c(){n=g("button"),s=O(a),this.h()},l(e){n=_(e,"BUTTON",{class:!0});var u=$(n);s=R(u,a),u.forEach(i),this.h()},h(){H(n,"class",t=`tab tab-md tab-lifted ${c[6].active?"tab-active":""}`)},m(e,u){k(e,n,u),T(n,s),p||(l=Rn(n,"click",o),p=!0)},p(e,u){c=e,u&1&&a!==(a=c[6].name+"")&&An(s,a),u&1&&t!==(t=`tab tab-md tab-lifted ${c[6].active?"tab-active":""}`)&&H(n,"class",t)},d(e){e&&i(n),p=!1,l()}}}function Pn(c){let n;const a=c[4].default,s=jn(a,c,c[3],wn);return{c(){s&&s.c()},l(t){s&&s.l(t)},m(t,p){s&&s.m(t,p),n=!0},p(t,p){s&&s.p&&(!n||p&10)&&Hn(s,a,t,t[3],n?Cn(a,t[3],p,Dn):xn(t[3]),wn)},i(t){n||(m(s,t),n=!0)},o(t){d(s,t),n=!1},d(t){s&&s.d(t)}}}function In(c){let n,a,s,t,p=c[0],l=[];for(let e=0;e<p.length;e+=1)l[e]=hn(bn(c,p,e));let o=c[1]&&c[1].active&&Pn(c);return{c(){n=g("div");for(let e=0;e<l.length;e+=1)l[e].c();a=q(),o&&o.c(),s=F(),this.h()},l(e){n=_(e,"DIV",{class:!0});var u=$(n);for(let f=0;f<l.length;f+=1)l[f].l(u);u.forEach(i),a=E(e),o&&o.l(e),s=F(),this.h()},h(){H(n,"class","tabs")},m(e,u){k(e,n,u);for(let f=0;f<l.length;f+=1)l[f].m(n,null);k(e,a,u),o&&o.m(e,u),k(e,s,u),t=!0},p(e,[u]){if(u&5){p=e[0];let f;for(f=0;f<p.length;f+=1){const x=bn(e,p,f);l[f]?l[f].p(x,u):(l[f]=hn(x),l[f].c(),l[f].m(n,null))}for(;f<l.length;f+=1)l[f].d(1);l.length=p.length}e[1]&&e[1].active?o?(o.p(e,u),u&2&&m(o,1)):(o=Pn(e),o.c(),m(o,1),o.m(s.parentNode,s)):o&&(G(),d(o,1,1,()=>{o=null}),J())},i(e){t||(m(o),t=!0)},o(e){d(o),t=!1},d(e){e&&i(n),On(l,e),e&&i(a),o&&o.d(e),e&&i(s)}}}function Gn(c,n,a){let s,{$$slots:t={},$$scope:p}=n,{tabs:l}=n;const o=u=>{a(0,l=l.map(f=>({...f,active:f.name===u})))},e=u=>o(u.name);return c.$$set=u=>{"tabs"in u&&a(0,l=u.tabs),"$$scope"in u&&a(3,p=u.$$scope)},c.$$.update=()=>{c.$$.dirty&1&&a(1,s=l.find(u=>u.active))},[l,s,o,p,t,e]}class fn extends A{constructor(n){super(),j(this,n,Gn,In,S,{tabs:0})}}function Jn(c){let n,a=`<code class="language-ts"><span class="token comment">// Sample interfaces</span>
<span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">interface</span> <span class="token class-name">PersonPaginated</span> <span class="token punctuation">&#123;</span>
  data<span class="token operator">:</span> Person<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  page<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  limit<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">const</span> find <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
  paginated <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  limit <span class="token operator">=</span> <span class="token number">10</span>
<span class="token punctuation">&#125;</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
  paginated<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
  limit<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>Person<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> PersonPaginated<span class="token operator">></span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// Return the paginated data if paginated is true</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>paginated<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> data<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'Arya Stark'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'Jon Snow'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">,</span> limit<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span> page<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>

  <span class="token comment">// Otherwise return the array of people</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'Arya Stark'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'Jon Snow'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">main</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> people<span class="token operator">:</span> Person<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> PersonPaginated <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> paginated<span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> paginated_people<span class="token operator">:</span> Person<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> PersonPaginated <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code>`;return{c(){n=g("pre"),this.h()},l(s){n=_(s,"PRE",{class:!0});var t=$(n);t.forEach(i),this.h()},h(){H(n,"class","language-ts")},m(s,t){k(s,n,t),n.innerHTML=a},p:w,i:w,o:w,d(s){s&&i(n)}}}class Ln extends A{constructor(n){super(),j(this,n,null,Jn,S,{})}}function Mn(c){let n,a=`<code class="language-ts"><span class="token comment">// Sample interfaces</span>
<span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// Paginated could now be used for multiple data types</span>
<span class="token keyword">interface</span> <span class="token class-name">Paginated<span class="token operator">&lt;</span>Type<span class="token operator">></span></span> <span class="token punctuation">&#123;</span>
  data<span class="token operator">:</span> Type<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  page<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  limit<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// Parameter typing moved out to an interface</span>
<span class="token class-name"><span class="token keyword">interface</span></span> Parameters <span class="token punctuation">&#123;</span>
  paginated<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
  limit<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// Dynamic type "function" where PartialParameters is actually like a Typescript parameter</span>
<span class="token keyword">type</span> <span class="token class-name">ResponseForFind<span class="token operator">&lt;</span>PartialParameters<span class="token operator">></span></span> <span class="token operator">=</span> PartialParameters <span class="token keyword">extends</span> <span class="token punctuation">&#123;</span> paginated<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">&#125;</span>
  <span class="token operator">?</span> Paginated<span class="token operator">&lt;</span>Person<span class="token operator">></span>
  <span class="token operator">:</span> Person<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// Find function now has generics used for typing its parameters</span>
<span class="token keyword">const</span> find <span class="token operator">=</span> <span class="token generic-function"><span class="token function">async</span> <span class="token generic class-name"><span class="token operator">&lt;</span>PartialParameters <span class="token keyword">extends</span> Parameters<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
  paginated <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  limit <span class="token operator">=</span> <span class="token number">10</span>
<span class="token punctuation">&#125;</span><span class="token operator">:</span> PartialParameters<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>ResponseForFind<span class="token operator">&lt;</span>PartialParameters<span class="token operator">>></span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// Return type does have to be forced inside of the find function</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>paginated<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>
      data<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'Arya Stark'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'Jon Snow'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
      limit<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span>
      page<span class="token operator">:</span> <span class="token number">0</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">as</span> ResponseForFind<span class="token operator">&lt;</span>PartialParameters<span class="token operator">></span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>

  <span class="token comment">// Return type does have to be forced inside of the find function</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'Arya Stark'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'Jon Snow'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">]</span> <span class="token keyword">as</span> ResponseForFind<span class="token operator">&lt;</span>PartialParameters<span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// Types would now be known because we can type check based on the parameters passed to the function</span>
<span class="token keyword">const</span> <span class="token function-variable function">main</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> people<span class="token operator">:</span> Person<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> paginated<span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> paginated_people<span class="token operator">:</span> Paginated<span class="token operator">&lt;</span>Person<span class="token operator">></span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> paginated<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code>`;return{c(){n=g("pre"),this.h()},l(s){n=_(s,"PRE",{class:!0});var t=$(n);t.forEach(i),this.h()},h(){H(n,"class","language-ts")},m(s,t){k(s,n,t),n.innerHTML=a},p:w,i:w,o:w,d(s){s&&i(n)}}}class Qn extends A{constructor(n){super(),j(this,n,null,Mn,S,{})}}function Un(c){let n,a;return n=new Qn({}),{c(){b(n.$$.fragment)},l(s){h(n.$$.fragment,s)},m(s,t){P(n,s,t),a=!0},i(s){a||(m(n.$$.fragment,s),a=!0)},o(s){d(n.$$.fragment,s),a=!1},d(s){v(n,s)}}}function Vn(c){let n,a;return n=new Ln({}),{c(){b(n.$$.fragment)},l(s){h(n.$$.fragment,s)},m(s,t){P(n,s,t),a=!0},i(s){a||(m(n.$$.fragment,s),a=!0)},o(s){d(n.$$.fragment,s),a=!1},d(s){v(n,s)}}}function vn(c){let n,a,s,t;const p=[Vn,Un],l=[];function o(e,u){return e[0].name==="original"?0:1}return n=o(c),a=l[n]=p[n](c),{c(){a.c(),s=F()},l(e){a.l(e),s=F()},m(e,u){l[n].m(e,u),k(e,s,u),t=!0},p(e,u){let f=n;n=o(e),n!==f&&(G(),d(l[f],1,1,()=>{l[f]=null}),J(),a=l[n],a||(a=l[n]=p[n](e),a.c()),m(a,1),a.m(s.parentNode,s))},i(e){t||(m(a),t=!0)},o(e){d(a),t=!1},d(e){l[n].d(e),e&&i(s)}}}function Bn(c){let n=c[0].name,a,s,t=vn(c);return{c(){t.c(),a=F()},l(p){t.l(p),a=F()},m(p,l){t.m(p,l),k(p,a,l),s=!0},p(p,l){l&1&&S(n,n=p[0].name)?(G(),d(t,1,1,w),J(),t=vn(p),t.c(),m(t,1),t.m(a.parentNode,a)):t.p(p,l)},i(p){s||(m(t),s=!0)},o(p){d(t),s=!1},d(p){p&&i(a),t.d(p)}}}function Kn(c){let n,a,s,t,p,l;return p=new fn({props:{tabs:[{name:"original",active:!0},{name:"advanced",active:!1}],$$slots:{default:[Bn,({active_tab:o})=>({0:o}),({active_tab:o})=>o?1:0]},$$scope:{ctx:c}}}),{c(){n=g("p"),a=g("strong"),s=O("So to start we\u2019ll take a look at a fake HTTP GET endpoint that can return paginated data or an array of data"),t=q(),b(p.$$.fragment)},l(o){n=_(o,"P",{});var e=$(n);a=_(e,"STRONG",{});var u=$(a);s=R(u,"So to start we\u2019ll take a look at a fake HTTP GET endpoint that can return paginated data or an array of data"),u.forEach(i),e.forEach(i),t=E(o),h(p.$$.fragment,o)},m(o,e){k(o,n,e),T(n,a),T(a,s),k(o,t,e),P(p,o,e),l=!0},p(o,[e]){const u={};e&3&&(u.$$scope={dirty:e,ctx:o}),p.$set(u)},i(o){l||(m(p.$$.fragment,o),l=!0)},o(o){d(p.$$.fragment,o),l=!1},d(o){o&&i(n),o&&i(t),v(p,o)}}}class zn extends A{constructor(n){super(),j(this,n,null,Kn,S,{})}}function Wn(c){let n,a=`<code class="language-ts"><span class="token comment">// Sample Database import</span>
<span class="token keyword">import</span> db <span class="token keyword">from</span> <span class="token string">'./path/to/db'</span><span class="token punctuation">;</span>

<span class="token comment">// Sample interfaces</span>
<span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">const</span> create <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span>personOrPeople<span class="token operator">:</span> Person <span class="token operator">|</span> Person<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>Person<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> Person<span class="token operator">></span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> db<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>personOrPeople<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">main</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// Return types are not inferred by the data passed to the create function</span>
  <span class="token keyword">const</span> people<span class="token operator">:</span> Person<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> Person <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">[</span> <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'Arya Stark'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'Jon Snow'</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> person<span class="token operator">:</span> Person<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> Person <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'Jon Snow'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code>`;return{c(){n=g("pre"),this.h()},l(s){n=_(s,"PRE",{class:!0});var t=$(n);t.forEach(i),this.h()},h(){H(n,"class","language-ts")},m(s,t){k(s,n,t),n.innerHTML=a},p:w,i:w,o:w,d(s){s&&i(n)}}}class Xn extends A{constructor(n){super(),j(this,n,null,Wn,S,{})}}function Yn(c){let n,a=`<code class="language-ts"><span class="token comment">// Sample Database import</span>
<span class="token keyword">import</span> db <span class="token keyword">from</span> <span class="token string">'./path/to/db'</span><span class="token punctuation">;</span>

<span class="token comment">// Sample interfaces (stands in as a Database model as well)</span>
<span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// Using Partial&lt;Person>[] because PersonOrPeopleToCreate likely doesn't have all</span>
<span class="token comment">// Of the required properties (id likely generated by the database)</span>
<span class="token keyword">type</span> <span class="token class-name">ResponseForCreate<span class="token operator">&lt;</span>PersonOrPeopleToCreate<span class="token operator">></span></span> <span class="token operator">=</span> PersonOrPeopleToCreate <span class="token keyword">extends</span> <span class="token class-name">Partial<span class="token operator">&lt;</span>Person<span class="token operator">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token operator">?</span> Person<span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token operator">:</span> Person<span class="token punctuation">;</span>

<span class="token keyword">const</span> create <span class="token operator">=</span> <span class="token generic-function"><span class="token function">async</span> <span class="token generic class-name"><span class="token operator">&lt;</span>PersonOrPeopleToCreate <span class="token keyword">extends</span> Person <span class="token operator">|</span> Person<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>
  personOrPeople<span class="token operator">:</span> PersonOrPeopleToCreate
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>ResponseForCreate<span class="token operator">&lt;</span>PersonOrPeopleToCreate<span class="token operator">>></span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> createdData <span class="token operator">=</span> <span class="token keyword">await</span> db<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>personOrPeople<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> createdData <span class="token keyword">as</span> ResponseForCreate<span class="token operator">&lt;</span>PersonOrPeopleToCreate<span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">main</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// Return types are inferred by the data passed to the create function</span>
  <span class="token keyword">const</span> people<span class="token operator">:</span> Person<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'Arya Stark'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'Jon Snow'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> person<span class="token operator">:</span> Person <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'Jon Snow'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code>`;return{c(){n=g("pre"),this.h()},l(s){n=_(s,"PRE",{class:!0});var t=$(n);t.forEach(i),this.h()},h(){H(n,"class","language-ts")},m(s,t){k(s,n,t),n.innerHTML=a},p:w,i:w,o:w,d(s){s&&i(n)}}}class Zn extends A{constructor(n){super(),j(this,n,null,Yn,S,{})}}function ns(c){let n,a;return n=new Zn({}),{c(){b(n.$$.fragment)},l(s){h(n.$$.fragment,s)},m(s,t){P(n,s,t),a=!0},i(s){a||(m(n.$$.fragment,s),a=!0)},o(s){d(n.$$.fragment,s),a=!1},d(s){v(n,s)}}}function ss(c){let n,a;return n=new Xn({}),{c(){b(n.$$.fragment)},l(s){h(n.$$.fragment,s)},m(s,t){P(n,s,t),a=!0},i(s){a||(m(n.$$.fragment,s),a=!0)},o(s){d(n.$$.fragment,s),a=!1},d(s){v(n,s)}}}function Tn(c){let n,a,s,t;const p=[ss,ns],l=[];function o(e,u){return e[0].name==="original"?0:1}return n=o(c),a=l[n]=p[n](c),{c(){a.c(),s=F()},l(e){a.l(e),s=F()},m(e,u){l[n].m(e,u),k(e,s,u),t=!0},p(e,u){let f=n;n=o(e),n!==f&&(G(),d(l[f],1,1,()=>{l[f]=null}),J(),a=l[n],a||(a=l[n]=p[n](e),a.c()),m(a,1),a.m(s.parentNode,s))},i(e){t||(m(a),t=!0)},o(e){d(a),t=!1},d(e){l[n].d(e),e&&i(s)}}}function as(c){let n=c[0].name,a,s,t=Tn(c);return{c(){t.c(),a=F()},l(p){t.l(p),a=F()},m(p,l){t.m(p,l),k(p,a,l),s=!0},p(p,l){l&1&&S(n,n=p[0].name)?(G(),d(t,1,1,w),J(),t=Tn(p),t.c(),m(t,1),t.m(a.parentNode,a)):t.p(p,l)},i(p){s||(m(t),s=!0)},o(p){d(t),s=!1},d(p){p&&i(a),t.d(p)}}}function ts(c){let n,a,s,t,p,l;return p=new fn({props:{tabs:[{name:"original",active:!0},{name:"advanced",active:!1}],$$slots:{default:[as,({active_tab:o})=>({0:o}),({active_tab:o})=>o?1:0]},$$scope:{ctx:c}}}),{c(){n=g("p"),a=g("strong"),s=O("So to start we\u2019ll take a look at a fake HTTP POST endpoint that can return a singular object or an array of objects"),t=q(),b(p.$$.fragment)},l(o){n=_(o,"P",{});var e=$(n);a=_(e,"STRONG",{});var u=$(a);s=R(u,"So to start we\u2019ll take a look at a fake HTTP POST endpoint that can return a singular object or an array of objects"),u.forEach(i),e.forEach(i),t=E(o),h(p.$$.fragment,o)},m(o,e){k(o,n,e),T(n,a),T(a,s),k(o,t,e),P(p,o,e),l=!0},p(o,[e]){const u={};e&3&&(u.$$scope={dirty:e,ctx:o}),p.$set(u)},i(o){l||(m(p.$$.fragment,o),l=!0)},o(o){d(p.$$.fragment,o),l=!1},d(o){o&&i(n),o&&i(t),v(p,o)}}}class es extends A{constructor(n){super(),j(this,n,null,ts,S,{})}}function ps(c){let n,a=`<code class="language-ts"><span class="token comment">// Sample enum for different types of requests</span>
<span class="token keyword">enum</span> FindTypes <span class="token punctuation">&#123;</span>
  single_date <span class="token operator">=</span> <span class="token string">'single_date'</span><span class="token punctuation">,</span>
  date_range <span class="token operator">=</span> <span class="token string">'date_range'</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// Sample query for possible options</span>
<span class="token keyword">interface</span> <span class="token class-name">Query</span> <span class="token punctuation">&#123;</span>
  to<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  <span class="token comment">// from is only necessary if requesting a date_range</span>
  from<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// Interface for function parameters</span>
<span class="token keyword">interface</span> <span class="token class-name">FindParameter</span> <span class="token punctuation">&#123;</span>
  type<span class="token operator">:</span> FindTypes<span class="token punctuation">;</span>
  query<span class="token operator">:</span> Query<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// Interface for response data type</span>
<span class="token class-name"><span class="token keyword">interface</span></span> Article <span class="token punctuation">&#123;</span>
  title<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  content<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">const</span> find <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">&#123;</span> type<span class="token punctuation">,</span> query <span class="token punctuation">&#125;</span><span class="token operator">:</span> FindParameter<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>Article<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> queryObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URLSearchParams</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token operator">...</span>query <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span>
    <span class="token template-string"><span class="token template-punctuation string">&#96;</span><span class="token string">https://some-date-data.com?format=json&amp;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>queryObject<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">&#96;</span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">main</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// Only sending 'to' into the query as it's all that is required</span>
  <span class="token keyword">const</span> single_day_of_articles<span class="token operator">:</span> Article<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
    type<span class="token operator">:</span> FindTypes<span class="token punctuation">.</span>single_date<span class="token punctuation">,</span>
    query<span class="token operator">:</span> <span class="token punctuation">&#123;</span> to<span class="token operator">:</span> <span class="token string">'2022-08-01'</span> <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// Sending both 'to' and 'from' as both are technincally required for the API</span>
  <span class="token comment">// But not required by the interface used for function parameters</span>
  <span class="token keyword">const</span> multiple_days_of_articles<span class="token operator">:</span> Article<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
    type<span class="token operator">:</span> FindTypes<span class="token punctuation">.</span>date_range<span class="token punctuation">,</span>
    query<span class="token operator">:</span> <span class="token punctuation">&#123;</span> to<span class="token operator">:</span> <span class="token string">'2022-08-01'</span><span class="token punctuation">,</span> from<span class="token operator">:</span> <span class="token string">'2022-08-08'</span> <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// This would fail but you wouldn't know until this code executes</span>
  <span class="token keyword">const</span> error_getting_articles<span class="token operator">:</span> Article<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
    type<span class="token operator">:</span> FindTypes<span class="token punctuation">.</span>date_range<span class="token punctuation">,</span>
    query<span class="token operator">:</span> <span class="token punctuation">&#123;</span> to<span class="token operator">:</span> <span class="token string">'2022-08-01'</span> <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code>`;return{c(){n=g("pre"),this.h()},l(s){n=_(s,"PRE",{class:!0});var t=$(n);t.forEach(i),this.h()},h(){H(n,"class","language-ts")},m(s,t){k(s,n,t),n.innerHTML=a},p:w,i:w,o:w,d(s){s&&i(n)}}}class os extends A{constructor(n){super(),j(this,n,null,ps,S,{})}}function cs(c){let n,a=`<code class="language-ts"><span class="token comment">// Sample enum for different types of requests</span>
<span class="token keyword">enum</span> FindTypes <span class="token punctuation">&#123;</span>
  single_date <span class="token operator">=</span> <span class="token string">'single_date'</span><span class="token punctuation">,</span>
  date_range <span class="token operator">=</span> <span class="token string">'date_range'</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> <span class="token class-name">Query<span class="token operator">&lt;</span>FindType<span class="token operator">></span></span> <span class="token operator">=</span> FindType <span class="token keyword">extends</span> <span class="token class-name">FindTypes</span><span class="token punctuation">.</span>date_range
  <span class="token operator">?</span> <span class="token punctuation">&#123;</span> to<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> from<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">&#125;</span>
  <span class="token operator">:</span> <span class="token punctuation">&#123;</span> to<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name">FindParameter<span class="token operator">&lt;</span>PartialFindTypes<span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  type<span class="token operator">:</span> PartialFindTypes<span class="token punctuation">;</span>
  query<span class="token operator">:</span> Query<span class="token operator">&lt;</span>PartialFindTypes<span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// Interface for response data type</span>
<span class="token class-name"><span class="token keyword">interface</span></span> Article <span class="token punctuation">&#123;</span>
  title<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  content<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">const</span> find <span class="token operator">=</span> <span class="token generic-function"><span class="token function">async</span> <span class="token generic class-name"><span class="token operator">&lt;</span>PartialFindType <span class="token keyword">extends</span> FindTypes<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
  type<span class="token punctuation">,</span>
  query
<span class="token punctuation">&#125;</span><span class="token operator">:</span> FindParameter<span class="token operator">&lt;</span>PartialFindType<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>Article<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> queryObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URLSearchParams</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token operator">...</span>query <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span>
    <span class="token template-string"><span class="token template-punctuation string">&#96;</span><span class="token string">https://some-date-data.com?format=json&amp;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>queryObject<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">&#96;</span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">main</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// Only sending 'to' into the query as it's all that is required</span>
  <span class="token keyword">const</span> single_day_of_articles<span class="token operator">:</span> Article<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
    type<span class="token operator">:</span> FindTypes<span class="token punctuation">.</span>single_date<span class="token punctuation">,</span>
    query<span class="token operator">:</span> <span class="token punctuation">&#123;</span> to<span class="token operator">:</span> <span class="token string">'2022-08-01'</span> <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// Sending both 'to' and 'from' as both are required by the API and the</span>
  <span class="token comment">// Find function parameter type</span>
  <span class="token class-name"><span class="token keyword">const</span></span> multiple_days_of_articles<span class="token operator">:</span> Article<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
    type<span class="token operator">:</span> FindTypes<span class="token punctuation">.</span>date_range<span class="token punctuation">,</span>
    query<span class="token operator">:</span> <span class="token punctuation">&#123;</span> to<span class="token operator">:</span> <span class="token string">'2022-08-01'</span><span class="token punctuation">,</span> from<span class="token operator">:</span> <span class="token string">'2022-08-08'</span> <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// This would now show proper syntax errors</span>
  <span class="token comment">// As it is missing the 'from' property on the query</span>
  <span class="token keyword">const</span> error_getting_articles<span class="token operator">:</span> Article<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
    type<span class="token operator">:</span> FindTypes<span class="token punctuation">.</span>date_range<span class="token punctuation">,</span>
    query<span class="token operator">:</span> <span class="token punctuation">&#123;</span> to<span class="token operator">:</span> <span class="token string">'2022-08-01'</span> <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code>`;return{c(){n=g("pre"),this.h()},l(s){n=_(s,"PRE",{class:!0});var t=$(n);t.forEach(i),this.h()},h(){H(n,"class","language-ts")},m(s,t){k(s,n,t),n.innerHTML=a},p:w,i:w,o:w,d(s){s&&i(n)}}}class ls extends A{constructor(n){super(),j(this,n,null,cs,S,{})}}function rs(c){let n,a;return n=new ls({}),{c(){b(n.$$.fragment)},l(s){h(n.$$.fragment,s)},m(s,t){P(n,s,t),a=!0},i(s){a||(m(n.$$.fragment,s),a=!0)},o(s){d(n.$$.fragment,s),a=!1},d(s){v(n,s)}}}function us(c){let n,a;return n=new os({}),{c(){b(n.$$.fragment)},l(s){h(n.$$.fragment,s)},m(s,t){P(n,s,t),a=!0},i(s){a||(m(n.$$.fragment,s),a=!0)},o(s){d(n.$$.fragment,s),a=!1},d(s){v(n,s)}}}function Sn(c){let n,a,s,t;const p=[us,rs],l=[];function o(e,u){return e[0].name==="original"?0:1}return n=o(c),a=l[n]=p[n](c),{c(){a.c(),s=F()},l(e){a.l(e),s=F()},m(e,u){l[n].m(e,u),k(e,s,u),t=!0},p(e,u){let f=n;n=o(e),n!==f&&(G(),d(l[f],1,1,()=>{l[f]=null}),J(),a=l[n],a||(a=l[n]=p[n](e),a.c()),m(a,1),a.m(s.parentNode,s))},i(e){t||(m(a),t=!0)},o(e){d(a),t=!1},d(e){l[n].d(e),e&&i(s)}}}function is(c){let n=c[0].name,a,s,t=Sn(c);return{c(){t.c(),a=F()},l(p){t.l(p),a=F()},m(p,l){t.m(p,l),k(p,a,l),s=!0},p(p,l){l&1&&S(n,n=p[0].name)?(G(),d(t,1,1,w),J(),t=Sn(p),t.c(),m(t,1),t.m(a.parentNode,a)):t.p(p,l)},i(p){s||(m(t),s=!0)},o(p){d(t),s=!1},d(p){p&&i(a),t.d(p)}}}function ks(c){let n,a,s,t,p,l;return p=new fn({props:{tabs:[{name:"original",active:!0},{name:"advanced",active:!1}],$$slots:{default:[is,({active_tab:o})=>({0:o}),({active_tab:o})=>o?1:0]},$$scope:{ctx:c}}}),{c(){n=g("p"),a=g("strong"),s=O("So to start we\u2019ll take a look at a fake HTTP POST endpoint that can return a singular object or an array of objects"),t=q(),b(p.$$.fragment)},l(o){n=_(o,"P",{});var e=$(n);a=_(e,"STRONG",{});var u=$(a);s=R(u,"So to start we\u2019ll take a look at a fake HTTP POST endpoint that can return a singular object or an array of objects"),u.forEach(i),e.forEach(i),t=E(o),h(p.$$.fragment,o)},m(o,e){k(o,n,e),T(n,a),T(a,s),k(o,t,e),P(p,o,e),l=!0},p(o,[e]){const u={};e&3&&(u.$$scope={dirty:e,ctx:o}),p.$set(u)},i(o){l||(m(p.$$.fragment,o),l=!0)},o(o){d(p.$$.fragment,o),l=!1},d(o){o&&i(n),o&&i(t),v(p,o)}}}class fs extends A{constructor(n){super(),j(this,n,null,ks,S,{})}}function ms(c){let n;return{c(){n=O(qn)},l(a){n=R(a,qn)},m(a,s){k(a,n,s)},p:w,d(a){a&&i(n)}}}function ds(c){let n;return{c(){n=O("Paginated Data")},l(a){n=R(a,"Paginated Data")},m(a,s){k(a,n,s)},d(a){a&&i(n)}}}function ys(c){let n,a;return n=new kn({props:{display:"contents",slot:"title",$$slots:{default:[ds]},$$scope:{ctx:c}}}),{c(){b(n.$$.fragment)},l(s){h(n.$$.fragment,s)},m(s,t){P(n,s,t),a=!0},p(s,t){const p={};t&1&&(p.$$scope={dirty:t,ctx:s}),n.$set(p)},i(s){a||(m(n.$$.fragment,s),a=!0)},o(s){d(n.$$.fragment,s),a=!1},d(s){v(n,s)}}}function gs(c){let n,a;return n=new zn({props:{slot:"content"}}),{c(){b(n.$$.fragment)},l(s){h(n.$$.fragment,s)},m(s,t){P(n,s,t),a=!0},p:w,i(s){a||(m(n.$$.fragment,s),a=!0)},o(s){d(n.$$.fragment,s),a=!1},d(s){v(n,s)}}}function _s(c){let n;return{c(){n=O("Creating Data")},l(a){n=R(a,"Creating Data")},m(a,s){k(a,n,s)},d(a){a&&i(n)}}}function $s(c){let n,a;return n=new kn({props:{display:"contents",slot:"title",$$slots:{default:[_s]},$$scope:{ctx:c}}}),{c(){b(n.$$.fragment)},l(s){h(n.$$.fragment,s)},m(s,t){P(n,s,t),a=!0},p(s,t){const p={};t&1&&(p.$$scope={dirty:t,ctx:s}),n.$set(p)},i(s){a||(m(n.$$.fragment,s),a=!0)},o(s){d(n.$$.fragment,s),a=!1},d(s){v(n,s)}}}function ws(c){let n,a;return n=new es({props:{slot:"content"}}),{c(){b(n.$$.fragment)},l(s){h(n.$$.fragment,s)},m(s,t){P(n,s,t),a=!0},p:w,i(s){a||(m(n.$$.fragment,s),a=!0)},o(s){d(n.$$.fragment,s),a=!1},d(s){v(n,s)}}}function bs(c){let n;return{c(){n=O("Function Parameters")},l(a){n=R(a,"Function Parameters")},m(a,s){k(a,n,s)},d(a){a&&i(n)}}}function hs(c){let n,a;return n=new kn({props:{display:"contents",slot:"title",$$slots:{default:[bs]},$$scope:{ctx:c}}}),{c(){b(n.$$.fragment)},l(s){h(n.$$.fragment,s)},m(s,t){P(n,s,t),a=!0},p(s,t){const p={};t&1&&(p.$$scope={dirty:t,ctx:s}),n.$set(p)},i(s){a||(m(n.$$.fragment,s),a=!0)},o(s){d(n.$$.fragment,s),a=!1},d(s){v(n,s)}}}function Ps(c){let n,a;return n=new fs({props:{slot:"content"}}),{c(){b(n.$$.fragment)},l(s){h(n.$$.fragment,s)},m(s,t){P(n,s,t),a=!0},p:w,i(s){a||(m(n.$$.fragment,s),a=!0)},o(s){d(n.$$.fragment,s),a=!1},d(s){v(n,s)}}}function vs(c){let n,a,s,t,p,l,o,e=`<code class="language-ts"><span class="token keyword">const</span> x<span class="token operator">:</span> Person <span class="token operator">|</span> Person<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
  <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'Jon Snow'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'Arya Stark'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'Sansa Stark'</span> <span class="token punctuation">&#125;</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code>`,u,f,x,on,X,I,En=`<code class="language-ts"><span class="token keyword">const</span> <span class="token function-variable function">create_job</span> <span class="token operator">=</span> <span class="token punctuation">(</span>parameters<span class="token operator">:</span> <span class="token punctuation">&#123;</span> type<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> options<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> some<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// Example of additional actions taken with the options</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>parameters<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">'requires_other_parameters'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// This would normally cause errors since options is optional</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Required Parameters: '</span><span class="token punctuation">,</span> parameters<span class="token punctuation">.</span>options<span class="token punctuation">.</span>some<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>

  <span class="token keyword">return</span> <span class="token string">'Job Created'</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> job1 <span class="token operator">=</span> <span class="token function">create_job</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> type<span class="token operator">:</span> <span class="token string">'no_other_required_parameters'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// options is not required</span>
<span class="token keyword">const</span> job2 <span class="token operator">=</span> <span class="token function">create_job</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
  type<span class="token operator">:</span> <span class="token string">'requires_other_parameters'</span><span class="token punctuation">,</span>
  options<span class="token operator">:</span> <span class="token punctuation">&#123;</span> some<span class="token operator">:</span> <span class="token string">'other_parameter'</span> <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// options is required</span></code>`,Y,L,U,cn,Z,C,nn,N,sn,D,an,M,V,ln,tn,Q,B,rn,en;return n=new Nn({props:{$$slots:{default:[ms]},$$scope:{ctx:c}}}),C=new un({props:{$$slots:{content:[gs],title:[ys]},$$scope:{ctx:c}}}),N=new un({props:{$$slots:{content:[ws],title:[$s]},$$scope:{ctx:c}}}),D=new un({props:{$$slots:{content:[Ps],title:[hs]},$$scope:{ctx:c}}}),{c(){b(n.$$.fragment),a=q(),s=g("p"),t=g("strong"),p=O("Have you ever run into an issue where a function can return multiple types?"),l=q(),o=g("pre"),u=q(),f=g("p"),x=g("strong"),on=O("Or how about a function whose required parameters can change depending on a related but separate parameter?"),X=q(),I=g("pre"),Y=q(),L=g("p"),U=g("strong"),cn=O("This has been an issue that has come up numerous times for me since working full-time on web applications with Typescript. So today I want to go over some ways that these situations can be improved."),Z=q(),b(C.$$.fragment),nn=q(),b(N.$$.fragment),sn=q(),b(D.$$.fragment),an=q(),M=g("p"),V=g("strong"),ln=O("So with those examples, I hope you can see how adding in a little bit of advanced Typescript can help you code without remembering all of the nuances of different processes."),tn=q(),Q=g("p"),B=g("strong"),rn=O("It\u2019s also worth noting that many of these examples contain more code than the original however it should be quite reusable as the majority of the principles are similar."),this.h()},l(r){h(n.$$.fragment,r),a=E(r),s=_(r,"P",{});var y=$(s);t=_(y,"STRONG",{});var K=$(t);p=R(K,"Have you ever run into an issue where a function can return multiple types?"),K.forEach(i),y.forEach(i),l=E(r),o=_(r,"PRE",{class:!0});var pn=$(o);pn.forEach(i),u=E(r),f=_(r,"P",{});var z=$(f);x=_(z,"STRONG",{});var W=$(x);on=R(W,"Or how about a function whose required parameters can change depending on a related but separate parameter?"),W.forEach(i),z.forEach(i),X=E(r),I=_(r,"PRE",{class:!0});var Fn=$(I);Fn.forEach(i),Y=E(r),L=_(r,"P",{});var mn=$(L);U=_(mn,"STRONG",{});var dn=$(U);cn=R(dn,"This has been an issue that has come up numerous times for me since working full-time on web applications with Typescript. So today I want to go over some ways that these situations can be improved."),dn.forEach(i),mn.forEach(i),Z=E(r),h(C.$$.fragment,r),nn=E(r),h(N.$$.fragment,r),sn=E(r),h(D.$$.fragment,r),an=E(r),M=_(r,"P",{});var yn=$(M);V=_(yn,"STRONG",{});var gn=$(V);ln=R(gn,"So with those examples, I hope you can see how adding in a little bit of advanced Typescript can help you code without remembering all of the nuances of different processes."),gn.forEach(i),yn.forEach(i),tn=E(r),Q=_(r,"P",{});var _n=$(Q);B=_(_n,"STRONG",{});var $n=$(B);rn=R($n,"It\u2019s also worth noting that many of these examples contain more code than the original however it should be quite reusable as the majority of the principles are similar."),$n.forEach(i),_n.forEach(i),this.h()},h(){H(o,"class","language-ts"),H(I,"class","language-ts")},m(r,y){P(n,r,y),k(r,a,y),k(r,s,y),T(s,t),T(t,p),k(r,l,y),k(r,o,y),o.innerHTML=e,k(r,u,y),k(r,f,y),T(f,x),T(x,on),k(r,X,y),k(r,I,y),I.innerHTML=En,k(r,Y,y),k(r,L,y),T(L,U),T(U,cn),k(r,Z,y),P(C,r,y),k(r,nn,y),P(N,r,y),k(r,sn,y),P(D,r,y),k(r,an,y),k(r,M,y),T(M,V),T(V,ln),k(r,tn,y),k(r,Q,y),T(Q,B),T(B,rn),en=!0},p(r,[y]){const K={};y&1&&(K.$$scope={dirty:y,ctx:r}),n.$set(K);const pn={};y&1&&(pn.$$scope={dirty:y,ctx:r}),C.$set(pn);const z={};y&1&&(z.$$scope={dirty:y,ctx:r}),N.$set(z);const W={};y&1&&(W.$$scope={dirty:y,ctx:r}),D.$set(W)},i(r){en||(m(n.$$.fragment,r),m(C.$$.fragment,r),m(N.$$.fragment,r),m(D.$$.fragment,r),en=!0)},o(r){d(n.$$.fragment,r),d(C.$$.fragment,r),d(N.$$.fragment,r),d(D.$$.fragment,r),en=!1},d(r){v(n,r),r&&i(a),r&&i(s),r&&i(l),r&&i(o),r&&i(u),r&&i(f),r&&i(X),r&&i(I),r&&i(Y),r&&i(L),r&&i(Z),v(C,r),r&&i(nn),v(N,r),r&&i(sn),v(D,r),r&&i(an),r&&i(M),r&&i(tn),r&&i(Q)}}}const Ts={title:"Typescript Dynamic Typing",description:"Types that use types to make your life easier.",topics:"typescript"},{title:qn,description:Rs,topics:As}=Ts;class Ss extends A{constructor(n){super(),j(this,n,null,vs,S,{})}}function qs(c){let n,a;return n=new Ss({}),{c(){b(n.$$.fragment)},l(s){h(n.$$.fragment,s)},m(s,t){P(n,s,t),a=!0},p:w,i(s){a||(m(n.$$.fragment,s),a=!0)},o(s){d(n.$$.fragment,s),a=!1},d(s){v(n,s)}}}class js extends A{constructor(n){super(),j(this,n,null,qs,S,{})}}export{js as default};
