import{S as D,i as H,s as O,D as an,k as _,l as y,m as $,h as u,n as q,b as f,H as tn,I as en,J as pn,f as m,t as d,a as j,e as x,c as A,g as Q,d as B,K as Cn,q as N,r as C,E as P,G as xn,u as Un,A as b,v,w as T,x as S,y as E}from"../../../../chunks/index-372a785c.js";function Vn(p){let n,a;const s=p[1].default,t=an(s,p,p[0],null);return{c(){n=_("h1"),t&&t.c(),this.h()},l(e){n=y(e,"H1",{class:!0});var l=$(n);t&&t.l(l),l.forEach(u),this.h()},h(){q(n,"class","text-5xl font-bold")},m(e,l){f(e,n,l),t&&t.m(n,null),a=!0},p(e,[l]){t&&t.p&&(!a||l&1)&&tn(t,s,e,e[0],a?pn(s,e[0],l,null):en(e[0]),null)},i(e){a||(m(t,e),a=!0)},o(e){d(t,e),a=!1},d(e){e&&u(n),t&&t.d(e)}}}function Gn(p,n,a){let{$$slots:s={},$$scope:t}=n;return p.$$set=e=>{"$$scope"in e&&a(0,t=e.$$scope)},[t,s]}class Jn extends D{constructor(n){super(),H(this,n,Gn,Vn,O,{})}}function Ln(p){let n,a;const s=p[1].default,t=an(s,p,p[0],null);return{c(){n=_("h2"),t&&t.c(),this.h()},l(e){n=y(e,"H2",{class:!0});var l=$(n);t&&t.l(l),l.forEach(u),this.h()},h(){q(n,"class","text-4xl font-bold")},m(e,l){f(e,n,l),t&&t.m(n,null),a=!0},p(e,[l]){t&&t.p&&(!a||l&1)&&tn(t,s,e,e[0],a?pn(s,e[0],l,null):en(e[0]),null)},i(e){a||(m(t,e),a=!0)},o(e){d(t,e),a=!1},d(e){e&&u(n),t&&t.d(e)}}}function Mn(p,n,a){let{$$slots:s={},$$scope:t}=n;return p.$$set=e=>{"$$scope"in e&&a(0,t=e.$$scope)},[t,s]}class $n extends D{constructor(n){super(),H(this,n,Mn,Ln,O,{})}}const Qn=p=>({active_tab:p&2}),En=p=>({active_tab:p[1]});function qn(p,n,a){const s=p.slice();return s[6]=n[a],s}function Fn(p){let n,a=p[6].name+"",s,t,e,l;function o(){return p[5](p[6])}return{c(){n=_("button"),s=N(a),this.h()},l(c){n=y(c,"BUTTON",{class:!0});var i=$(n);s=C(i,a),i.forEach(u),this.h()},h(){q(n,"class",t=`tab tab-md tab-lifted ${p[6].active?"tab-active":""}`)},m(c,i){f(c,n,i),P(n,s),e||(l=xn(n,"click",o),e=!0)},p(c,i){p=c,i&1&&a!==(a=p[6].name+"")&&Un(s,a),i&1&&t!==(t=`tab tab-md tab-lifted ${p[6].active?"tab-active":""}`)&&q(n,"class",t)},d(c){c&&u(n),e=!1,l()}}}function On(p){let n;const a=p[4].default,s=an(a,p,p[3],En);return{c(){s&&s.c()},l(t){s&&s.l(t)},m(t,e){s&&s.m(t,e),n=!0},p(t,e){s&&s.p&&(!n||e&10)&&tn(s,a,t,t[3],n?pn(a,t[3],e,Qn):en(t[3]),En)},i(t){n||(m(s,t),n=!0)},o(t){d(s,t),n=!1},d(t){s&&s.d(t)}}}function Bn(p){let n,a,s,t,e=p[0],l=[];for(let c=0;c<e.length;c+=1)l[c]=Fn(qn(p,e,c));let o=p[1]&&p[1].active&&On(p);return{c(){n=_("div");for(let c=0;c<l.length;c+=1)l[c].c();a=j(),o&&o.c(),s=x(),this.h()},l(c){n=y(c,"DIV",{class:!0});var i=$(n);for(let k=0;k<l.length;k+=1)l[k].l(i);i.forEach(u),a=A(c),o&&o.l(c),s=x(),this.h()},h(){q(n,"class","tabs")},m(c,i){f(c,n,i);for(let k=0;k<l.length;k+=1)l[k].m(n,null);f(c,a,i),o&&o.m(c,i),f(c,s,i),t=!0},p(c,[i]){if(i&5){e=c[0];let k;for(k=0;k<e.length;k+=1){const h=qn(c,e,k);l[k]?l[k].p(h,i):(l[k]=Fn(h),l[k].c(),l[k].m(n,null))}for(;k<l.length;k+=1)l[k].d(1);l.length=e.length}c[1]&&c[1].active?o?(o.p(c,i),i&2&&m(o,1)):(o=On(c),o.c(),m(o,1),o.m(s.parentNode,s)):o&&(Q(),d(o,1,1,()=>{o=null}),B())},i(c){t||(m(o),t=!0)},o(c){d(o),t=!1},d(c){c&&u(n),Cn(l,c),c&&u(a),o&&o.d(c),c&&u(s)}}}function Kn(p,n,a){let s,{$$slots:t={},$$scope:e}=n,{tabs:l}=n;const o=i=>{a(0,l=l.map(k=>({...k,active:k.name===i})))},c=i=>o(i.name);return p.$$set=i=>{"tabs"in i&&a(0,l=i.tabs),"$$scope"in i&&a(3,e=i.$$scope)},p.$$.update=()=>{p.$$.dirty&1&&a(1,s=l.find(i=>i.active))},[l,s,o,e,t,c]}class wn extends D{constructor(n){super(),H(this,n,Kn,Bn,O,{tabs:0})}}function zn(p){let n,a=`<code class="language-ts"><span class="token comment">// Sample interfaces</span>
<span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">interface</span> <span class="token class-name">PersonPaginated</span> <span class="token punctuation">&#123;</span>
  data<span class="token operator">:</span> Person<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  page<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  limit<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">const</span> find <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
  paginated <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  limit <span class="token operator">=</span> <span class="token number">10</span>
<span class="token punctuation">&#125;</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
  paginated<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
  limit<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>Person<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> PersonPaginated<span class="token operator">></span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// Return the paginated data if paginated is true</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>paginated<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> data<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'Arya Start'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'Jon Snow'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">,</span> limit<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span> page<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>

  <span class="token comment">// Otherwise return the array of people</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'Arya Start'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'Jon Snow'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">main</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> people<span class="token operator">:</span> Person<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> PersonPaginated <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> paginated<span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> paginated_people<span class="token operator">:</span> Person<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> PersonPaginated <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code>`;return{c(){n=_("pre"),this.h()},l(s){n=y(s,"PRE",{class:!0});var t=$(n);t.forEach(u),this.h()},h(){q(n,"class","language-ts")},m(s,t){f(s,n,t),n.innerHTML=a},p:b,i:b,o:b,d(s){s&&u(n)}}}class Wn extends D{constructor(n){super(),H(this,n,null,zn,O,{})}}function Xn(p){let n,a=`<code class="language-ts"><span class="token comment">// Sample interfaces</span>
<span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// Paginated could now be used for multiple data types</span>
<span class="token keyword">interface</span> <span class="token class-name">Paginated<span class="token operator">&lt;</span>Type<span class="token operator">></span></span> <span class="token punctuation">&#123;</span>
  data<span class="token operator">:</span> Type<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  page<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  limit<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// Parameter typing moved out to an interface</span>
<span class="token class-name"><span class="token keyword">interface</span></span> Parameters <span class="token punctuation">&#123;</span>
  paginated<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
  limit<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// Dynamic type "function" where PartialParameters is actually like a Typescript parameter</span>
<span class="token keyword">type</span> <span class="token class-name">ResponseForFind<span class="token operator">&lt;</span>PartialParameters<span class="token operator">></span></span> <span class="token operator">=</span> PartialParameters <span class="token keyword">extends</span> <span class="token punctuation">&#123;</span> paginated<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">&#125;</span>
  <span class="token operator">?</span> Paginated<span class="token operator">&lt;</span>Person<span class="token operator">></span>
  <span class="token operator">:</span> Person<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// Find function now has generics used for typing its parameters</span>
<span class="token keyword">const</span> find <span class="token operator">=</span> <span class="token generic-function"><span class="token function">async</span> <span class="token generic class-name"><span class="token operator">&lt;</span>PartialParameters <span class="token keyword">extends</span> Parameters<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
  paginated <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  limit <span class="token operator">=</span> <span class="token number">10</span>
<span class="token punctuation">&#125;</span><span class="token operator">:</span> PartialParameters<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>ResponseForFind<span class="token operator">&lt;</span>PartialParameters<span class="token operator">>></span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// Return type does have to be forced inside of the find function</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>paginated<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>
      data<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'Arya Start'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'Jon Snow'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
      limit<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span>
      page<span class="token operator">:</span> <span class="token number">0</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">as</span> ResponseForFind<span class="token operator">&lt;</span>PartialParameters<span class="token operator">></span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>

  <span class="token comment">// Return type does have to be forced inside of the find function</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'Arya Start'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'Jon Snow'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">]</span> <span class="token keyword">as</span> ResponseForFind<span class="token operator">&lt;</span>PartialParameters<span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// Types would now be known because we can type check based on the parameters passed to the function</span>
<span class="token keyword">const</span> <span class="token function-variable function">main</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> people<span class="token operator">:</span> Person<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> paginated<span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> paginated_people<span class="token operator">:</span> Paginated<span class="token operator">&lt;</span>Person<span class="token operator">></span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> paginated<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code>`;return{c(){n=_("pre"),this.h()},l(s){n=y(s,"PRE",{class:!0});var t=$(n);t.forEach(u),this.h()},h(){q(n,"class","language-ts")},m(s,t){f(s,n,t),n.innerHTML=a},p:b,i:b,o:b,d(s){s&&u(n)}}}class Yn extends D{constructor(n){super(),H(this,n,null,Xn,O,{})}}function Zn(p){let n,a;return n=new Yn({}),{c(){v(n.$$.fragment)},l(s){T(n.$$.fragment,s)},m(s,t){S(n,s,t),a=!0},i(s){a||(m(n.$$.fragment,s),a=!0)},o(s){d(n.$$.fragment,s),a=!1},d(s){E(n,s)}}}function ns(p){let n,a;return n=new Wn({}),{c(){v(n.$$.fragment)},l(s){T(n.$$.fragment,s)},m(s,t){S(n,s,t),a=!0},i(s){a||(m(n.$$.fragment,s),a=!0)},o(s){d(n.$$.fragment,s),a=!1},d(s){E(n,s)}}}function Rn(p){let n,a,s,t;const e=[ns,Zn],l=[];function o(c,i){return c[0].name==="original"?0:1}return n=o(p),a=l[n]=e[n](p),{c(){a.c(),s=x()},l(c){a.l(c),s=x()},m(c,i){l[n].m(c,i),f(c,s,i),t=!0},p(c,i){let k=n;n=o(c),n!==k&&(Q(),d(l[k],1,1,()=>{l[k]=null}),B(),a=l[n],a||(a=l[n]=e[n](c),a.c()),m(a,1),a.m(s.parentNode,s))},i(c){t||(m(a),t=!0)},o(c){d(a),t=!1},d(c){l[n].d(c),c&&u(s)}}}function ss(p){let n=p[0].name,a,s,t=Rn(p);return{c(){t.c(),a=x()},l(e){t.l(e),a=x()},m(e,l){t.m(e,l),f(e,a,l),s=!0},p(e,l){l&1&&O(n,n=e[0].name)?(Q(),d(t,1,1,b),B(),t=Rn(e),t.c(),m(t,1),t.m(a.parentNode,a)):t.p(e,l)},i(e){s||(m(t),s=!0)},o(e){d(t),s=!1},d(e){e&&u(a),t.d(e)}}}function as(p){let n,a,s,t,e,l;return e=new wn({props:{tabs:[{name:"original",active:!0},{name:"advanced",active:!1}],$$slots:{default:[ss,({active_tab:o})=>({0:o}),({active_tab:o})=>o?1:0]},$$scope:{ctx:p}}}),{c(){n=_("p"),a=_("strong"),s=N("So to start we\u2019ll take a look at a fake HTTP GET endpoint that can return paginated data or an array of data"),t=j(),v(e.$$.fragment)},l(o){n=y(o,"P",{});var c=$(n);a=y(c,"STRONG",{});var i=$(a);s=C(i,"So to start we\u2019ll take a look at a fake HTTP GET endpoint that can return paginated data or an array of data"),i.forEach(u),c.forEach(u),t=A(o),T(e.$$.fragment,o)},m(o,c){f(o,n,c),P(n,a),P(a,s),f(o,t,c),S(e,o,c),l=!0},p(o,[c]){const i={};c&3&&(i.$$scope={dirty:c,ctx:o}),e.$set(i)},i(o){l||(m(e.$$.fragment,o),l=!0)},o(o){d(e.$$.fragment,o),l=!1},d(o){o&&u(n),o&&u(t),E(e,o)}}}class ts extends D{constructor(n){super(),H(this,n,null,as,O,{})}}function es(p){let n,a=`<code class="language-ts"><span class="token comment">// Sample Database import</span>
<span class="token keyword">import</span> db <span class="token keyword">from</span> <span class="token string">'./path/to/db'</span><span class="token punctuation">;</span>

<span class="token comment">// Sample interfaces</span>
<span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">const</span> create <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span>personOrPeople<span class="token operator">:</span> Person <span class="token operator">|</span> Person<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>Person<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> Person<span class="token operator">></span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> db<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>personOrPeople<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">main</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// Return types are not inferred by the data passed to the create function</span>
  <span class="token keyword">const</span> people<span class="token operator">:</span> Person<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> Person <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">[</span> <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'Arya Stark'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'Jon Snow'</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> person<span class="token operator">:</span> Person<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> Person <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'Jon Snow'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code>`;return{c(){n=_("pre"),this.h()},l(s){n=y(s,"PRE",{class:!0});var t=$(n);t.forEach(u),this.h()},h(){q(n,"class","language-ts")},m(s,t){f(s,n,t),n.innerHTML=a},p:b,i:b,o:b,d(s){s&&u(n)}}}class ps extends D{constructor(n){super(),H(this,n,null,es,O,{})}}function os(p){let n,a=`<code class="language-ts"><span class="token comment">// Sample Database import</span>
<span class="token keyword">import</span> db <span class="token keyword">from</span> <span class="token string">'./path/to/db'</span><span class="token punctuation">;</span>

<span class="token comment">// Sample interfaces (stands in as a Database model as well)</span>
<span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// Using Partial&lt;Person>[] because PersonOrPeopleToCreate likely doesn't have all</span>
<span class="token comment">// Of the required properties (id likely generated by the database)</span>
<span class="token keyword">type</span> <span class="token class-name">ResponseForCreate<span class="token operator">&lt;</span>PersonOrPeopleToCreate<span class="token operator">></span></span> <span class="token operator">=</span> PersonOrPeopleToCreate <span class="token keyword">extends</span> <span class="token class-name">Partial<span class="token operator">&lt;</span>Person<span class="token operator">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token operator">?</span> Person<span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token operator">:</span> Person<span class="token punctuation">;</span>

<span class="token keyword">const</span> create <span class="token operator">=</span> <span class="token generic-function"><span class="token function">async</span> <span class="token generic class-name"><span class="token operator">&lt;</span>PersonOrPeopleToCreate <span class="token keyword">extends</span> Person <span class="token operator">|</span> Person<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>
  personOrPeople<span class="token operator">:</span> PersonOrPeopleToCreate
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>ResponseForCreate<span class="token operator">&lt;</span>PersonOrPeopleToCreate<span class="token operator">>></span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> createdData <span class="token operator">=</span> <span class="token keyword">await</span> db<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>personOrPeople<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> createdData <span class="token keyword">as</span> ResponseForCreate<span class="token operator">&lt;</span>PersonOrPeopleToCreate<span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">main</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// Return types are inferred by the data passed to the create function</span>
  <span class="token keyword">const</span> people<span class="token operator">:</span> Person<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'Arya Stark'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'Jon Snow'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> person<span class="token operator">:</span> Person <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'Jon Snow'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code>`;return{c(){n=_("pre"),this.h()},l(s){n=y(s,"PRE",{class:!0});var t=$(n);t.forEach(u),this.h()},h(){q(n,"class","language-ts")},m(s,t){f(s,n,t),n.innerHTML=a},p:b,i:b,o:b,d(s){s&&u(n)}}}class cs extends D{constructor(n){super(),H(this,n,null,os,O,{})}}function ls(p){let n,a;return n=new cs({}),{c(){v(n.$$.fragment)},l(s){T(n.$$.fragment,s)},m(s,t){S(n,s,t),a=!0},i(s){a||(m(n.$$.fragment,s),a=!0)},o(s){d(n.$$.fragment,s),a=!1},d(s){E(n,s)}}}function rs(p){let n,a;return n=new ps({}),{c(){v(n.$$.fragment)},l(s){T(n.$$.fragment,s)},m(s,t){S(n,s,t),a=!0},i(s){a||(m(n.$$.fragment,s),a=!0)},o(s){d(n.$$.fragment,s),a=!1},d(s){E(n,s)}}}function jn(p){let n,a,s,t;const e=[rs,ls],l=[];function o(c,i){return c[0].name==="original"?0:1}return n=o(p),a=l[n]=e[n](p),{c(){a.c(),s=x()},l(c){a.l(c),s=x()},m(c,i){l[n].m(c,i),f(c,s,i),t=!0},p(c,i){let k=n;n=o(c),n!==k&&(Q(),d(l[k],1,1,()=>{l[k]=null}),B(),a=l[n],a||(a=l[n]=e[n](c),a.c()),m(a,1),a.m(s.parentNode,s))},i(c){t||(m(a),t=!0)},o(c){d(a),t=!1},d(c){l[n].d(c),c&&u(s)}}}function us(p){let n=p[0].name,a,s,t=jn(p);return{c(){t.c(),a=x()},l(e){t.l(e),a=x()},m(e,l){t.m(e,l),f(e,a,l),s=!0},p(e,l){l&1&&O(n,n=e[0].name)?(Q(),d(t,1,1,b),B(),t=jn(e),t.c(),m(t,1),t.m(a.parentNode,a)):t.p(e,l)},i(e){s||(m(t),s=!0)},o(e){d(t),s=!1},d(e){e&&u(a),t.d(e)}}}function is(p){let n,a,s,t,e,l;return e=new wn({props:{tabs:[{name:"original",active:!0},{name:"advanced",active:!1}],$$slots:{default:[us,({active_tab:o})=>({0:o}),({active_tab:o})=>o?1:0]},$$scope:{ctx:p}}}),{c(){n=_("p"),a=_("strong"),s=N("So to start we\u2019ll take a look at a fake HTTP POST endpoint that can return a singular object or an array of objects"),t=j(),v(e.$$.fragment)},l(o){n=y(o,"P",{});var c=$(n);a=y(c,"STRONG",{});var i=$(a);s=C(i,"So to start we\u2019ll take a look at a fake HTTP POST endpoint that can return a singular object or an array of objects"),i.forEach(u),c.forEach(u),t=A(o),T(e.$$.fragment,o)},m(o,c){f(o,n,c),P(n,a),P(a,s),f(o,t,c),S(e,o,c),l=!0},p(o,[c]){const i={};c&3&&(i.$$scope={dirty:c,ctx:o}),e.$set(i)},i(o){l||(m(e.$$.fragment,o),l=!0)},o(o){d(e.$$.fragment,o),l=!1},d(o){o&&u(n),o&&u(t),E(e,o)}}}class ks extends D{constructor(n){super(),H(this,n,null,is,O,{})}}function fs(p){let n,a=`<code class="language-ts"><span class="token comment">// Sample enum for different types of requests</span>
<span class="token keyword">enum</span> FindTypes <span class="token punctuation">&#123;</span>
  single_date <span class="token operator">=</span> <span class="token string">'single_date'</span><span class="token punctuation">,</span>
  date_range <span class="token operator">=</span> <span class="token string">'date_range'</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// Sample query for possible options</span>
<span class="token keyword">interface</span> <span class="token class-name">Query</span> <span class="token punctuation">&#123;</span>
  to<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  <span class="token comment">// from is only necessary if requesting a date_range</span>
  from<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// Interface for function parameters</span>
<span class="token keyword">interface</span> <span class="token class-name">FindParameter</span> <span class="token punctuation">&#123;</span>
  type<span class="token operator">:</span> FindTypes<span class="token punctuation">;</span>
  query<span class="token operator">:</span> Query<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// Interface for response data type</span>
<span class="token class-name"><span class="token keyword">interface</span></span> Article <span class="token punctuation">&#123;</span>
  title<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  content<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">const</span> find <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">&#123;</span> type<span class="token punctuation">,</span> query <span class="token punctuation">&#125;</span><span class="token operator">:</span> FindParameter<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>Article<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> queryObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URLSearchParams</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token operator">...</span>query <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span>
    <span class="token template-string"><span class="token template-punctuation string">&#96;</span><span class="token string">https://some-date-data.com?format=json&amp;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>queryObject<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">&#96;</span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">main</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// Only sending 'to' into the query as it's all that is required</span>
  <span class="token keyword">const</span> single_day_of_articles<span class="token operator">:</span> Article<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
    type<span class="token operator">:</span> FindTypes<span class="token punctuation">.</span>single_date<span class="token punctuation">,</span>
    query<span class="token operator">:</span> <span class="token punctuation">&#123;</span> to<span class="token operator">:</span> <span class="token string">'2022-08-01'</span> <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// Sending both 'to' and 'from' as both are technincally required for the API</span>
  <span class="token comment">// But not required by the interface used for function parameters</span>
  <span class="token keyword">const</span> multiple_days_of_articles<span class="token operator">:</span> Article<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
    type<span class="token operator">:</span> FindTypes<span class="token punctuation">.</span>date_range<span class="token punctuation">,</span>
    query<span class="token operator">:</span> <span class="token punctuation">&#123;</span> to<span class="token operator">:</span> <span class="token string">'2022-08-01'</span><span class="token punctuation">,</span> from<span class="token operator">:</span> <span class="token string">'2022-08-08'</span> <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// This would fail but you wouldn't know until this code executes</span>
  <span class="token keyword">const</span> error_getting_articles<span class="token operator">:</span> Article<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
    type<span class="token operator">:</span> FindTypes<span class="token punctuation">.</span>date_range<span class="token punctuation">,</span>
    query<span class="token operator">:</span> <span class="token punctuation">&#123;</span> to<span class="token operator">:</span> <span class="token string">'2022-08-01'</span> <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code>`;return{c(){n=_("pre"),this.h()},l(s){n=y(s,"PRE",{class:!0});var t=$(n);t.forEach(u),this.h()},h(){q(n,"class","language-ts")},m(s,t){f(s,n,t),n.innerHTML=a},p:b,i:b,o:b,d(s){s&&u(n)}}}class ms extends D{constructor(n){super(),H(this,n,null,fs,O,{})}}function ds(p){let n,a=`<code class="language-ts"><span class="token comment">// Sample enum for different types of requests</span>
<span class="token keyword">enum</span> FindTypes <span class="token punctuation">&#123;</span>
  single_date <span class="token operator">=</span> <span class="token string">'single_date'</span><span class="token punctuation">,</span>
  date_range <span class="token operator">=</span> <span class="token string">'date_range'</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> <span class="token class-name">Query<span class="token operator">&lt;</span>FindType<span class="token operator">></span></span> <span class="token operator">=</span> FindType <span class="token keyword">extends</span> <span class="token class-name">FindTypes</span><span class="token punctuation">.</span>date_range
  <span class="token operator">?</span> <span class="token punctuation">&#123;</span> to<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> from<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">&#125;</span>
  <span class="token operator">:</span> <span class="token punctuation">&#123;</span> to<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name">FindParameter<span class="token operator">&lt;</span>PartialFindTypes<span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  type<span class="token operator">:</span> PartialFindTypes<span class="token punctuation">;</span>
  query<span class="token operator">:</span> Query<span class="token operator">&lt;</span>PartialFindTypes<span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// Interface for response data type</span>
<span class="token class-name"><span class="token keyword">interface</span></span> Article <span class="token punctuation">&#123;</span>
  title<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  content<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">const</span> find <span class="token operator">=</span> <span class="token generic-function"><span class="token function">async</span> <span class="token generic class-name"><span class="token operator">&lt;</span>PartialFindType <span class="token keyword">extends</span> FindTypes<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
  type<span class="token punctuation">,</span>
  query
<span class="token punctuation">&#125;</span><span class="token operator">:</span> FindParameter<span class="token operator">&lt;</span>PartialFindType<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>Article<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> queryObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URLSearchParams</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token operator">...</span>query <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span>
    <span class="token template-string"><span class="token template-punctuation string">&#96;</span><span class="token string">https://some-date-data.com?format=json&amp;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>queryObject<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">&#96;</span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">main</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// Only sending 'to' into the query as it's all that is required</span>
  <span class="token keyword">const</span> single_day_of_articles<span class="token operator">:</span> Article<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
    type<span class="token operator">:</span> FindTypes<span class="token punctuation">.</span>single_date<span class="token punctuation">,</span>
    query<span class="token operator">:</span> <span class="token punctuation">&#123;</span> to<span class="token operator">:</span> <span class="token string">'2022-08-01'</span> <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// Sending both 'to' and 'from' as both are required by the API and the</span>
  <span class="token comment">// Find function parameter type</span>
  <span class="token class-name"><span class="token keyword">const</span></span> multiple_days_of_articles<span class="token operator">:</span> Article<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
    type<span class="token operator">:</span> FindTypes<span class="token punctuation">.</span>date_range<span class="token punctuation">,</span>
    query<span class="token operator">:</span> <span class="token punctuation">&#123;</span> to<span class="token operator">:</span> <span class="token string">'2022-08-01'</span><span class="token punctuation">,</span> from<span class="token operator">:</span> <span class="token string">'2022-08-08'</span> <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// This would now show proper syntax errors</span>
  <span class="token comment">// As it is missing the 'from' property on the query</span>
  <span class="token keyword">const</span> error_getting_articles<span class="token operator">:</span> Article<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
    type<span class="token operator">:</span> FindTypes<span class="token punctuation">.</span>date_range<span class="token punctuation">,</span>
    query<span class="token operator">:</span> <span class="token punctuation">&#123;</span> to<span class="token operator">:</span> <span class="token string">'2022-08-01'</span> <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code>`;return{c(){n=_("pre"),this.h()},l(s){n=y(s,"PRE",{class:!0});var t=$(n);t.forEach(u),this.h()},h(){q(n,"class","language-ts")},m(s,t){f(s,n,t),n.innerHTML=a},p:b,i:b,o:b,d(s){s&&u(n)}}}class gs extends D{constructor(n){super(),H(this,n,null,ds,O,{})}}function _s(p){let n,a;return n=new gs({}),{c(){v(n.$$.fragment)},l(s){T(n.$$.fragment,s)},m(s,t){S(n,s,t),a=!0},i(s){a||(m(n.$$.fragment,s),a=!0)},o(s){d(n.$$.fragment,s),a=!1},d(s){E(n,s)}}}function ys(p){let n,a;return n=new ms({}),{c(){v(n.$$.fragment)},l(s){T(n.$$.fragment,s)},m(s,t){S(n,s,t),a=!0},i(s){a||(m(n.$$.fragment,s),a=!0)},o(s){d(n.$$.fragment,s),a=!1},d(s){E(n,s)}}}function An(p){let n,a,s,t;const e=[ys,_s],l=[];function o(c,i){return c[0].name==="original"?0:1}return n=o(p),a=l[n]=e[n](p),{c(){a.c(),s=x()},l(c){a.l(c),s=x()},m(c,i){l[n].m(c,i),f(c,s,i),t=!0},p(c,i){let k=n;n=o(c),n!==k&&(Q(),d(l[k],1,1,()=>{l[k]=null}),B(),a=l[n],a||(a=l[n]=e[n](c),a.c()),m(a,1),a.m(s.parentNode,s))},i(c){t||(m(a),t=!0)},o(c){d(a),t=!1},d(c){l[n].d(c),c&&u(s)}}}function $s(p){let n=p[0].name,a,s,t=An(p);return{c(){t.c(),a=x()},l(e){t.l(e),a=x()},m(e,l){t.m(e,l),f(e,a,l),s=!0},p(e,l){l&1&&O(n,n=e[0].name)?(Q(),d(t,1,1,b),B(),t=An(e),t.c(),m(t,1),t.m(a.parentNode,a)):t.p(e,l)},i(e){s||(m(t),s=!0)},o(e){d(t),s=!1},d(e){e&&u(a),t.d(e)}}}function ws(p){let n,a,s,t,e,l;return e=new wn({props:{tabs:[{name:"original",active:!0},{name:"advanced",active:!1}],$$slots:{default:[$s,({active_tab:o})=>({0:o}),({active_tab:o})=>o?1:0]},$$scope:{ctx:p}}}),{c(){n=_("p"),a=_("strong"),s=N("So to start we\u2019ll take a look at a fake HTTP POST endpoint that can return a singular object or an array of objects"),t=j(),v(e.$$.fragment)},l(o){n=y(o,"P",{});var c=$(n);a=y(c,"STRONG",{});var i=$(a);s=C(i,"So to start we\u2019ll take a look at a fake HTTP POST endpoint that can return a singular object or an array of objects"),i.forEach(u),c.forEach(u),t=A(o),T(e.$$.fragment,o)},m(o,c){f(o,n,c),P(n,a),P(a,s),f(o,t,c),S(e,o,c),l=!0},p(o,[c]){const i={};c&3&&(i.$$scope={dirty:c,ctx:o}),e.$set(i)},i(o){l||(m(e.$$.fragment,o),l=!0)},o(o){d(e.$$.fragment,o),l=!1},d(o){o&&u(n),o&&u(t),E(e,o)}}}class bs extends D{constructor(n){super(),H(this,n,null,ws,O,{})}}let mn;const hs=new Uint8Array(16);function Ps(){if(!mn&&(mn=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!mn))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return mn(hs)}const R=[];for(let p=0;p<256;++p)R.push((p+256).toString(16).slice(1));function vs(p,n=0){return(R[p[n+0]]+R[p[n+1]]+R[p[n+2]]+R[p[n+3]]+"-"+R[p[n+4]]+R[p[n+5]]+"-"+R[p[n+6]]+R[p[n+7]]+"-"+R[p[n+8]]+R[p[n+9]]+"-"+R[p[n+10]]+R[p[n+11]]+R[p[n+12]]+R[p[n+13]]+R[p[n+14]]+R[p[n+15]]).toLowerCase()}const Ts=typeof crypto<"u"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto),In={randomUUID:Ts};function Ss(p,n,a){if(In.randomUUID&&!n&&!p)return In.randomUUID();p=p||{};const s=p.random||(p.rng||Ps)();if(s[6]=s[6]&15|64,s[8]=s[8]&63|128,n){a=a||0;for(let t=0;t<16;++t)n[a+t]=s[t];return n}return vs(s)}const Es=p=>({}),Dn=p=>({}),qs=p=>({}),Hn=p=>({});function Fs(p){let n,a,s,t,e,l,o,c,i;const k=p[3].title,h=an(k,p,p[2],Hn),L=p[3].content,F=an(L,p,p[2],Dn);return{c(){n=_("div"),a=_("input"),s=j(),t=_("div"),h&&h.c(),e=j(),l=_("div"),F&&F.c(),this.h()},l(w){n=y(w,"DIV",{class:!0});var I=$(n);a=y(I,"INPUT",{type:!0,class:!0}),s=A(I),t=y(I,"DIV",{class:!0});var M=$(t);h&&h.l(M),M.forEach(u),e=A(I),l=y(I,"DIV",{class:!0,id:!0});var U=$(l);F&&F.l(U),U.forEach(u),I.forEach(u),this.h()},h(){q(a,"type","checkbox"),q(a,"class","peer"),q(t,"class","collapse-title bg-base-100 text-primary-content peer-checked:bg-base-200 peer-checked:text-secondary-content"),q(l,"class","collapse-content bg-base-100 text-primary-content peer-checked:bg-base-200 peer-checked:text-secondary-content"),q(l,"id",`content-${p[0]}`),q(n,"class","collapse")},m(w,I){f(w,n,I),P(n,a),P(n,s),P(n,t),h&&h.m(t,null),P(n,e),P(n,l),F&&F.m(l,null),o=!0,c||(i=xn(a,"click",p[1]),c=!0)},p(w,[I]){h&&h.p&&(!o||I&4)&&tn(h,k,w,w[2],o?pn(k,w[2],I,qs):en(w[2]),Hn),F&&F.p&&(!o||I&4)&&tn(F,L,w,w[2],o?pn(L,w[2],I,Es):en(w[2]),Dn)},i(w){o||(m(h,w),m(F,w),o=!0)},o(w){d(h,w),d(F,w),o=!1},d(w){w&&u(n),h&&h.d(w),F&&F.d(w),c=!1,i()}}}function Os(p,n,a){let{$$slots:s={},$$scope:t}=n;const e=Ss();function l(){const o=document.querySelector(`#content-${e}`);!o||o.scrollIntoView({behavior:"smooth"})}return p.$$set=o=>{"$$scope"in o&&a(2,t=o.$$scope)},[e,l,t,s]}class yn extends D{constructor(n){super(),H(this,n,Os,Fs,O,{})}}function Rs(p){let n;return{c(){n=N("Typescript Dynamic Typing")},l(a){n=C(a,"Typescript Dynamic Typing")},m(a,s){f(a,n,s)},d(a){a&&u(n)}}}function js(p){let n;return{c(){n=N("Paginated Data")},l(a){n=C(a,"Paginated Data")},m(a,s){f(a,n,s)},d(a){a&&u(n)}}}function As(p){let n,a;return n=new $n({props:{slot:"title",$$slots:{default:[js]},$$scope:{ctx:p}}}),{c(){v(n.$$.fragment)},l(s){T(n.$$.fragment,s)},m(s,t){S(n,s,t),a=!0},p(s,t){const e={};t&1&&(e.$$scope={dirty:t,ctx:s}),n.$set(e)},i(s){a||(m(n.$$.fragment,s),a=!0)},o(s){d(n.$$.fragment,s),a=!1},d(s){E(n,s)}}}function Is(p){let n,a;return n=new ts({props:{slot:"content"}}),{c(){v(n.$$.fragment)},l(s){T(n.$$.fragment,s)},m(s,t){S(n,s,t),a=!0},p:b,i(s){a||(m(n.$$.fragment,s),a=!0)},o(s){d(n.$$.fragment,s),a=!1},d(s){E(n,s)}}}function Ds(p){let n;return{c(){n=N("Creating Data")},l(a){n=C(a,"Creating Data")},m(a,s){f(a,n,s)},d(a){a&&u(n)}}}function Hs(p){let n,a;return n=new $n({props:{slot:"title",$$slots:{default:[Ds]},$$scope:{ctx:p}}}),{c(){v(n.$$.fragment)},l(s){T(n.$$.fragment,s)},m(s,t){S(n,s,t),a=!0},p(s,t){const e={};t&1&&(e.$$scope={dirty:t,ctx:s}),n.$set(e)},i(s){a||(m(n.$$.fragment,s),a=!0)},o(s){d(n.$$.fragment,s),a=!1},d(s){E(n,s)}}}function xs(p){let n,a;return n=new ks({props:{slot:"content"}}),{c(){v(n.$$.fragment)},l(s){T(n.$$.fragment,s)},m(s,t){S(n,s,t),a=!0},p:b,i(s){a||(m(n.$$.fragment,s),a=!0)},o(s){d(n.$$.fragment,s),a=!1},d(s){E(n,s)}}}function Ns(p){let n;return{c(){n=N("Function Parameters")},l(a){n=C(a,"Function Parameters")},m(a,s){f(a,n,s)},d(a){a&&u(n)}}}function Cs(p){let n,a;return n=new $n({props:{slot:"title",$$slots:{default:[Ns]},$$scope:{ctx:p}}}),{c(){v(n.$$.fragment)},l(s){T(n.$$.fragment,s)},m(s,t){S(n,s,t),a=!0},p(s,t){const e={};t&1&&(e.$$scope={dirty:t,ctx:s}),n.$set(e)},i(s){a||(m(n.$$.fragment,s),a=!0)},o(s){d(n.$$.fragment,s),a=!1},d(s){E(n,s)}}}function Us(p){let n,a;return n=new bs({props:{slot:"content"}}),{c(){v(n.$$.fragment)},l(s){T(n.$$.fragment,s)},m(s,t){S(n,s,t),a=!0},p:b,i(s){a||(m(n.$$.fragment,s),a=!0)},o(s){d(n.$$.fragment,s),a=!1},d(s){E(n,s)}}}function Vs(p){let n,a,s,t,e,l,o,c=`<code class="language-ts"><span class="token keyword">const</span> x<span class="token operator">:</span> Person <span class="token operator">|</span> Person<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
  <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'Jon Snow'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'Arya Stark'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'Sansa Stark'</span> <span class="token punctuation">&#125;</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code>`,i,k,h,L,F,w,I=`<code class="language-ts"><span class="token keyword">const</span> <span class="token function-variable function">create_job</span> <span class="token operator">=</span> <span class="token punctuation">(</span>parameters<span class="token operator">:</span> <span class="token punctuation">&#123;</span> type<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> options<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> some<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// Example of additional actions taken with the options</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>parameters<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">'requires_other_parameters'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// This would normally cause errors since options is optional</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Required Parameters: '</span><span class="token punctuation">,</span> parameters<span class="token punctuation">.</span>options<span class="token punctuation">.</span>some<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>

  <span class="token keyword">return</span> <span class="token string">'Job Created'</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> job1 <span class="token operator">=</span> <span class="token function">create_job</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> type<span class="token operator">:</span> <span class="token string">'no_other_required_parameters'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// options is not required</span>
<span class="token keyword">const</span> job2 <span class="token operator">=</span> <span class="token function">create_job</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
  type<span class="token operator">:</span> <span class="token string">'requires_other_parameters'</span><span class="token punctuation">,</span>
  options<span class="token operator">:</span> <span class="token punctuation">&#123;</span> some<span class="token operator">:</span> <span class="token string">'other_parameter'</span> <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// options is required</span></code>`,M,U,W,dn,on,V,cn,G,ln,J,rn,K,X,gn,un,z,Y,_n,kn;return n=new Jn({props:{$$slots:{default:[Rs]},$$scope:{ctx:p}}}),V=new yn({props:{$$slots:{content:[Is],title:[As]},$$scope:{ctx:p}}}),G=new yn({props:{$$slots:{content:[xs],title:[Hs]},$$scope:{ctx:p}}}),J=new yn({props:{$$slots:{content:[Us],title:[Cs]},$$scope:{ctx:p}}}),{c(){v(n.$$.fragment),a=j(),s=_("p"),t=_("strong"),e=N("Have you ever run into an issue where a function can return multiple types?"),l=j(),o=_("pre"),i=j(),k=_("p"),h=_("strong"),L=N("Or how about a function whose required parameters can change depending on a related but separate parameter?"),F=j(),w=_("pre"),M=j(),U=_("p"),W=_("strong"),dn=N("This has been an issue that has come up numerous times for me since working full-time on web applications with Typescript. So today I want to go over some ways that these situations can be improved."),on=j(),v(V.$$.fragment),cn=j(),v(G.$$.fragment),ln=j(),v(J.$$.fragment),rn=j(),K=_("p"),X=_("strong"),gn=N("So with those examples, I hope you can see how adding in a little bit of advanced Typescript can help you code without remembering all of the nuances of different processes."),un=j(),z=_("p"),Y=_("strong"),_n=N("It\u2019s also worth noting that many of these examples contain more code than the original however it should be quite reusable as the majority of the principles are similar."),this.h()},l(r){T(n.$$.fragment,r),a=A(r),s=y(r,"P",{});var g=$(s);t=y(g,"STRONG",{});var Z=$(t);e=C(Z,"Have you ever run into an issue where a function can return multiple types?"),Z.forEach(u),g.forEach(u),l=A(r),o=y(r,"PRE",{class:!0});var fn=$(o);fn.forEach(u),i=A(r),k=y(r,"P",{});var nn=$(k);h=y(nn,"STRONG",{});var sn=$(h);L=C(sn,"Or how about a function whose required parameters can change depending on a related but separate parameter?"),sn.forEach(u),nn.forEach(u),F=A(r),w=y(r,"PRE",{class:!0});var Nn=$(w);Nn.forEach(u),M=A(r),U=y(r,"P",{});var bn=$(U);W=y(bn,"STRONG",{});var hn=$(W);dn=C(hn,"This has been an issue that has come up numerous times for me since working full-time on web applications with Typescript. So today I want to go over some ways that these situations can be improved."),hn.forEach(u),bn.forEach(u),on=A(r),T(V.$$.fragment,r),cn=A(r),T(G.$$.fragment,r),ln=A(r),T(J.$$.fragment,r),rn=A(r),K=y(r,"P",{});var Pn=$(K);X=y(Pn,"STRONG",{});var vn=$(X);gn=C(vn,"So with those examples, I hope you can see how adding in a little bit of advanced Typescript can help you code without remembering all of the nuances of different processes."),vn.forEach(u),Pn.forEach(u),un=A(r),z=y(r,"P",{});var Tn=$(z);Y=y(Tn,"STRONG",{});var Sn=$(Y);_n=C(Sn,"It\u2019s also worth noting that many of these examples contain more code than the original however it should be quite reusable as the majority of the principles are similar."),Sn.forEach(u),Tn.forEach(u),this.h()},h(){q(o,"class","language-ts"),q(w,"class","language-ts")},m(r,g){S(n,r,g),f(r,a,g),f(r,s,g),P(s,t),P(t,e),f(r,l,g),f(r,o,g),o.innerHTML=c,f(r,i,g),f(r,k,g),P(k,h),P(h,L),f(r,F,g),f(r,w,g),w.innerHTML=I,f(r,M,g),f(r,U,g),P(U,W),P(W,dn),f(r,on,g),S(V,r,g),f(r,cn,g),S(G,r,g),f(r,ln,g),S(J,r,g),f(r,rn,g),f(r,K,g),P(K,X),P(X,gn),f(r,un,g),f(r,z,g),P(z,Y),P(Y,_n),kn=!0},p(r,[g]){const Z={};g&1&&(Z.$$scope={dirty:g,ctx:r}),n.$set(Z);const fn={};g&1&&(fn.$$scope={dirty:g,ctx:r}),V.$set(fn);const nn={};g&1&&(nn.$$scope={dirty:g,ctx:r}),G.$set(nn);const sn={};g&1&&(sn.$$scope={dirty:g,ctx:r}),J.$set(sn)},i(r){kn||(m(n.$$.fragment,r),m(V.$$.fragment,r),m(G.$$.fragment,r),m(J.$$.fragment,r),kn=!0)},o(r){d(n.$$.fragment,r),d(V.$$.fragment,r),d(G.$$.fragment,r),d(J.$$.fragment,r),kn=!1},d(r){E(n,r),r&&u(a),r&&u(s),r&&u(l),r&&u(o),r&&u(i),r&&u(k),r&&u(F),r&&u(w),r&&u(M),r&&u(U),r&&u(on),E(V,r),r&&u(cn),E(G,r),r&&u(ln),E(J,r),r&&u(rn),r&&u(K),r&&u(un),r&&u(z)}}}class Gs extends D{constructor(n){super(),H(this,n,null,Vs,O,{})}}function Js(p){let n,a;return n=new Gs({}),{c(){v(n.$$.fragment)},l(s){T(n.$$.fragment,s)},m(s,t){S(n,s,t),a=!0},p:b,i(s){a||(m(n.$$.fragment,s),a=!0)},o(s){d(n.$$.fragment,s),a=!1},d(s){E(n,s)}}}class Ms extends D{constructor(n){super(),H(this,n,null,Js,O,{})}}export{Ms as default};
