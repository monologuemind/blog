<script lang='ts'>
  import H1 from '$components/markdown/H1.svelte';
  import H2 from '$components/markdown/H2.svelte';
</script>

<H1>Typescript Extractors</H1>


This whole article is intended to cover an issue that I have run into many times with the implementation of typescript for different libraries and frameworks. That issue being that some return types on functions can be multiple types without the function knowing which one it will return exactly.

This most common example I have is when using different ORM libraries (knex, sequelize, etc.). The two functions we can take a look at are the ones that return an array of data (find), and the ones that create data (post).

<H2>Find</H2>

When using find functions you often run into the issue of pagination. Most libraries will have a default option whether that's to return all data or a paginated set of that data. The paginated set typically has a slightly different structure than the full list of data.

Take the two object structures below:
```ts
[{name: "Mary Jane"}, {name: "Peter Parker"}]

// vs

{data: [{name: "Mary Jane"}], page: 1, limit: 1}
```

These two structures would be totally different types if you called the find function like so:
const response = await find(...); // People[] | Paginated`<People>`

This causes headaches for anyone useing the libraries like this when the maintainers could implement more advanced type inferences on the return types of functions.

They can do this because the way you would get the different return types will depend on the parameters given to the function itself.Tthe parameter interface passed to the find function can look like this:
``` ts
interface Parameters {
  limit: number;
  paginated: boolean;
}
```

The paginated property is what will determine the structure of the object you get back even though the return type is still an or.

To fix the return type can be changed to check the parameters that are passed in to decide the return type.
``` ts
export type ExtractPaginated<PartialParameters, Model> = 
  PartialParameters extends { paginated: true } ? 
    Paginated<Model> : 
      Model[];

interface People {
  name: string;
}

async find<PartialParameters extends Parameters>
  (parameters: PartialParameters): 
    Promise<ExtractPaginated<PartialParameters, People>> {
  // Run the same code that exists for the find function with the same returns;
  return .....;
}
```

To break down what is occuring here, we can start with the generic that the find function is using. We are saying the parameters will be of the generic type PartialParameters which extends the default Parameters interface (Not shown).
This means that you will retain type inference when using the find function (It will know that paginated and limit are possible properties).

Next we take on the ExtractPaginated beast, this is where the majority of the fun begins. To start off this type accepts two types, the PartialParameters which will be the same as the parameters passed to the find function and the "Model" which just represents the raw data you are trying to access.

Then we create the actual properties contained within this type dynamically, based on the two types that are passed to it. This is where we get to see the generics work together because the PartialParameters that we pass to this will know definitively whether paginated is true or false based on the actual parameter values passed to the find function.

The ExtractPaginated then is able to return the correct type specifically instead using an or. This removes any type coercion that a developer would have to do to ensure type safety when using a library like this.

<H2>Create</H2>

The same concepts can apply to the create function as well. In this case we have the following as our Extract type.

``` ts
// The any[] could also be Partial<Model>[] if the data is supposed to 
// Partially match the model itself however any array type will do
export type ExtractArray<DataToCreate, Model> = 
  DataToCreate extends any[] ? 
    Model[] : 
      Model;

function create<DataToCreate>(data: DataToCreate): 
    ExtractArray<DataToCreate, People> {
  // This is just an example of how this could work.
  // However most libraries already have this separated out...
  // Because they already support creating singular and multiple objects.
  if (Array.isArray(data)) {
    const ret: People[] = [{ name: 'Jon Snow' }];

    return ret as ExtractArray<DataToCreate, People>;
  }
  const ret: People = {
    name: 'Arya Stark';
  }

  return ret as ExtractArray<DataToCreate, People>;
}
```
That's all it takes, an extra type for to extract the return type based on the parameters sent to it. There are many other applications that this can apply to so if you find yourself either using them or if you seem the in use leave a comment so we can so people can check it out.